<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Longking Website - HomePage</title>

    <link rel="stylesheet" type="text/css" href="../css/base.css">
    <link rel="stylesheet" type="text/css" href="../css/spirit.css">
    <link rel="icon" href="../texture/icon.png">

    <script src="https://ajax.aspnetcdn.com/ajax/jquery/jquery-3.5.0.min.js"></script>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>

<body>

    <a href="#top-all" class="totop"></a>

    <div id="top-all">
        <div class="top" style="color: white;">
            --- welcome to longking's layer ---
        </div>
        <div class="top-selection">
            <a href="../index.html" style="text-decoration: underline; width: 25%; padding: 0 10px;">home</a>
            <a href="m&g.html" style="text-decoration: underline; width: 25%;padding: 0 10px;">m&g</a>
            <a href="spirit.html" style="text-decoration: underline; width: 25%;padding: 0 10px;">spirit</a>
            <a href="project.html" style="text-decoration: underline; width: 25%;padding: 0 10px;">project</a>
            <a href="about.html" style="text-decoration: underline; width: 25%;padding: 0 10px;">about</a>
            <br>
        </div>
        <div class="top-add">
            All the image textures are all from <a href="https://unsplash.com">unsplash<sup>&copy;</sup></a>
            <br>
            <span id="busuanzi_container_site_uv">Hits: <span id="busuanzi_value_site_uv"></span></span>
        </div>
    </div>

    <HR style="border:3 double center" width="100%" color=gray SIZE=3 >

    <div class="branch">
        <div class="nav-wrapper">
            <ul class="left">
                <li class="link" 
                style="font-size: 18px; 
                background: linear-gradient(to right, rgb(41, 41, 41), rgb(160, 160, 160));
                -webkit-background-clip: text;
                color: transparent;
                font-style: italic;">Code Tips
                    <ul class="nav">
                        <li class="next-link"><a href="#">前页</a></li>
                    </ul>

                <li class="link">Year 2022
                    <ul class="nav">
                        <li class="next-link"><a href="#">实例分割 调参Tips</a></li>
                        <li class="next-link"><a href="#">Selenium</a></li>
                        <li class="next-link"><a href="#">Github-Pages</a></li>
                        <li class="next-link"><a href="#">Pyinstaller Error</a></li>
                    </ul>
                </li>
                <li class="link">Year 2023
                    <ul class="nav">
                        <li class="next-link"><a href="#">MyBatisPlus 整合</a></li>
                        <li class="next-link"><a href="#">MMEditing使用</a></li>
                    </ul>
                </li>
                <li class="link">Year 2024
                    <ul class="nav">
                        <li class="next-link"><a href="#">同步录制电脑音视频</a></li>
                        <li class="next-link"><a href="#">2</a></li>
                    </ul>
                </li>
                <li class="link">-----
                    <ul class="nav">
                        <li class="next-link"><a href="#">1</a></li>
                        <li class="next-link"><a href="#">2</a></li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="right">
            <div class="item" id="i0">
                <div class="main-title">
                    Welcome
                </div>
                <div class="main-content">
                    <div class="content-title">写在前面</div>
                    <div class="content" id="content">
                        <p>旨在分析一个普通交叉学科学生的代码日常。</p>
                        <p>所有的分享都是基于实际自己做过的小案例, 毕竟文档大家都会看不是。</p>
                        <p>日期均为条目创建时间。</p>

                        <br>
                        <hr>
                        <br>

                        <p>
                            一直以来, 陆陆续续都有身边的朋友问我: 为什么要学写代码, 你是怎么学代码的(我不是科班背景, 甚至不是机械电气生信这类一般需要用到编程的专业), 该怎么学或者说该学哪些内容。
                            那我就放在前页这里吧, 算是这几年来的一个小总结, 也咨询了身边的科班大佬。<span style="color:red;">以下全部为个人意见, 不代表完全可靠。</span>
                        </p>

                        <br>
                        <p style="font-style:italic; font-size: 22px; font-weight:bold;">Why</p>
                        <br>
                        
                        <p>
                            <ul>
                                <li>个人爱好, 系统学习之前有一点基础算是。</li>
                                <li>剑走偏锋, 开辟新赛道, 未来更加灵活吧。</li>
                                <li>Coding对我来说, 不管是科研上工作上, 生活上社交上自己写点东西, 帮助他人也帮助自己。</li>
                            </ul>
                        </p>

                        <br>
                        <p style="font-style:italic; font-size: 22px; font-weight:bold;">What</p>
                        <br>
                        
                        <p><span style="color: red;">当你要去选择一个东西时, 你要想好你希望要从这个东西上获取什么</span></p>
                        <p>
                            我记得我跟别人讲过, 如果你升学进学校没有基础, 但是想学Coding的话, 首先要想好自己想用这个技能来做什么东西。大概总结了以下几种情况吧
                        </p>
                        <p>
                            <ul>
                                <li>
                                    想完全转行 ==> 这种情况我反而不推荐Python。PY的优点是学起来简单容易上手; 缺点也很明显, 第一慢, 第二纯Python岗位例如算法研发岗, C9的科班CS硕都不一定能招架。
                                    而且单论工作的话明显C++ / Java / JS甚至GoLang的工作是最多的也最普适的。
                                    所以这个时候不如去学一门JS或者JAVA, 等你还要学PY的时候也会简单很多毕竟从难倒易很轻松, 反过来就不一定了。
                                </li>
                                <li>
                                    想半转(交叉) ==> Python(或者R语言, 对于某些专业来说)作为ML/DL的核心语言肯定是你的不二之选。这个时候我不推荐你学Matlab, 因为既然你是半转行, 那么Matlab的局限就很大了。
                                    当然了, 等你做到部署的时候你还是要学C++, 但是咋说先把模型做出来不是。况且很多时候不需要部署。另外Java或者C++也是可以的, 比如专业性很强的软件公司, 业内企业的信息系统。
                                </li>
                                <li>
                                    只是为了搞科研 ==> Python/R/Matlab等均可, 看你的专业需求。
                                </li>
                            </ul>
                        </p>

                        <br>
                        <p style="font-style:italic; font-size: 22px; font-weight:bold;">How</p>
                        <br>

                        <p>
                            首先, 你得要会基础才能写, Hello World还有很多种写法不是。我个人的习惯是偏向视频(1.5倍速)学习, 书籍为辅。当然学习的方法仁者见仁, 适合自己的才是最好的。
                            对于视频方面, 比利比利大学作为国内一流大学, 每年都会输出很多很好的讲座/教学视频(bushi), 到上面找着看就行, 油管也可以当然需要你的英语水平达标了。一定要找那种讲的详细的, 多看几遍不要紧的。
                            不过要注意一点, 因为这类视频基本上都是面向就业的, 所以他们都会涉及到很多工作上的用途内容, 比如Linux操作/多并发等, 这些内容在你学习基础的时候是可以直接不看的。因此打个比方对于一个700集的视频来说, 基本上只用看1/3就可以了。
                            效率为王。买课的话, 我觉得没必要, 因为哪怕是身边科班的同学, 他们告诉我的情况是即便是科班甚至TOP科班, 大部分的Code Tricks也是非课堂时间学到的, 而且有的卖课的真的很水。
                        </p>
                        <p style="color: red;">
                            这里我想解释一下, 举个小例子。对于计算机专业或者机械电气信息等的同学来说, Linux很重要。事实上它们对我也很重要因为我的模型是在服务器上跑的, 操作系统是CentOS。
                            但是对于一些传统专业, 甚至都没有类似的编程环境和设备供使用, 与其去学一些如果不转行甚至都用不上的东西, 不如好好研究一下自己领域的东西不是吗。
                        </p>
                        <p>
                            Coding这个东西, 跟数学很像其实: 看着很简单, 一看就感觉会了, 一写就直接寄了, 一定要多练。这个时候有人就会问我怎么练。大概有两种渠道吧:
                            <ul>
                                <li>刷题网站 ==> Leetcode / pycheckio 等</li>
                                <li>
                                    在Github / CSDN 等上找案例(或者干脆自己想一个)自己练, 比如你在学PyQt5, 那么你就可以去自己写一个小计算器, 甚至一个文件管理系统等。
                                    要是ML/DL的话就更好说了, 国外去Kaggle / UCIMLR / AWS, 国内去天池 / PaddlePaddle 等直接找数据集, 学习别人优秀的代码怎么写的。
                                    记得我以前审过一篇某SCI Q1的文章, 交叉学科内容的, 作者很贴心附上了源码, 不过吧那个源码写的真的是一言难尽。后来把它拒了, 不过主要原因还是他的Method有问题跟代码没啥关系。
                                    这里我推荐一个清华毕业的微软大佬讲的Coding过程中命名方式的基本准则, 毕竟代码的可读性也很重要。<a href="https://www.bilibili.com/video/BV1RT411G73z">链接</a>这里
                                </li>
                            </ul>
                        </p>
                        <p>
                            然后我个人是极其推荐各位去刷刷题练练手, 看看别人代码的。很多方法可能你都不知道以至于花费了很多的时间去做无用功, 另外Coding是一件多人协作的东西, 你的代码质量关乎你的后期维护。
                            尤其对于交叉学科的同学来说, 看文档本身就是一件难以在短时间内习惯的事情。通过阅读别人的代码, 不仅能增加自己代码的编写水平, 掌握相应的Coding技巧, 还能了解到很多很好用的工具和方法。
                            任何语言也适用。
                        </p>
                        <br>
                        <p>
                            第二, 由于现在ML/DL的火热, 估计很多人在掌握好基础后都会想到往算法这边靠一点, 至少对研究有很大的好处。
                        </p>
                        <p>
                            基础当然是吴恩达老师的机器学习基础, 比利比利上有同源视频。虽然只用的话一个Sklearn / Pytorch 等Import就能解决, 但是再怎么说, 原理你得知道吧, 写代码虽说不一定什么时候都有造轮子的能力不能老当调包侠。
                            之后我是看的李航的数学统计方法, 深入了解这些ML Method的原理。之后又看了一些东西, 包括这些库怎么用, 若干案例分享七七八八的, 然后就去Kaggle上做练习去了。 
                        </p>
                        <p>
                            DL方面除了上面所提到的一些东西, arkiv上的论文, 比利比利上的各位大佬的精读讲解和经验分享(Mu Li is all your need)甚至知乎上的大佬(知乎计算机区还是很可靠的)都是可以学习的。
                            我认为CS领域给我留下最深刻的一点印象就是, 虽然真的很卷全是怪物, 但是很开放, 大家都愿意把自己写的代码放出来给别人参考或者指正。或许这也是它卷的根源之一, 但是对于小白来说真的极其友好。
                        </p>
                        <p>
                            之后因为要做部署, 就是顺带学了一下C++。从简单到困难真的很不容易, 一个指针概念我都看了三天还专门上油管看的印度人的视频, 劝大家学有余力的话都去试一下。
                        </p>
                        <p style="color: red;">
                            顺带一提, 当你在Coding上遇到Bug或者困难的时候, 多去查一查, Github / Stackoverflow / CSDN / 甚至专属的论坛, 你的错误可能别人早都发现并且解决了。
                            Coding有时候就像炼丹, Bug千奇百怪, 问一两个人真不一定能得到解决结果, 需要自己具有找寻答案的能力。
                        </p>
                        <br>
                        <p>
                            此外就是我个人学的一些其他东西了比如 MYSQL / HTML / JS / Java, 包括这些大类下的各类分支框架和要点。这么多语言这么多框架, 前端和后端这么多东西, 还是多学一点好, 也是一个完整项目的必要条件不是吗。
                        </p>

                    </div>
                </div>
            </div>

            <div class="item" id="i1">
                <div class="main-title">
                    2022-08-31
                </div>
                <div class="main-content">
                    <div class="content-title">Instance Segmentation 调参经验</div>
                    <div class="content" id="content">
                        <p>最近做的一个实例分割的任务, 先上调参前后的图片对比, 模型在经过多重比对后均使用<a href="https://arxiv.org/abs/2003.10152">SOLOV2</a>, backbone为ResNet-18, 没有大量魔改模型(比如加Attn等)</p>
                        <div class="imgbox">
                            <img src="../assets/2022/8-31/old.jpg">
                            <img src="../assets/2022/8-31/new.jpg">
                        </div>
                        <p>差的还是挺明显的。</p>
                        <p>数据集概况: 三类, 其中第一类为主要类别, 后两类是我希望让网络学到的废类别(相当于一种先验知识)。不然是很容易将这三类互相搞混的(实验得到)。三类数目分别为4700 3600 300, 每张图片大概有100-200个目标(三类加在一起)。图片大小为1200*800的双通道图(Hik原本拍出来的是3072*2048)。</p>
                        <p>设备概况: 一张NVIDIA-V100 32G, Python 3.9, Torch 1.11, CUDA 11.3, 基本上Batch只能有4, 训练500Epoch需要16h左右。顺带一提我这边的实验前40个Epoch AP稳定为0, 当时吓得以为我哪里整错了。</p>
                        <hr class="text-hr">
                        <p>调参嘛, 无非就是各种loss, lr, 以及结构参数之类的这些东西</p>
                        <p>首先, 这里的类别Loss选择的是Focal Loss。
                            由于FL主要是为了解决类别不平衡的问题, 其中alpha控制类别不平衡即alpha越小表示负样本越多; gamma控制难易样本的损失降低简单样本的损失值。
                            而这里如果把它肯成一个二分类问题的话, 其实还算比较平衡的, 因此将默认的alpha=0.25设置成了0.4-0.45。
                            分割Loss用的是DiceLoss, 就用的原始的参数, 还行其实。
                        </p>
                        <p>其次, 优化器选择的是原始的SGD(还蛮难下去的, 基本上就是前大后小), 初始学习率为0.05, 衰减方法选择的是StepLR。
                            由于我这里的BS和GPU个数较少, 一般所推荐的初始0.1或者0.01的学习率需要降低后再进行使用。
                            这里使用的是线性缩放原理, 参考文献为<a href="https://arxiv.org/abs/1706.02677" style="font-style: italic;">Accurate, Large Minibatch SGD:Training ImageNet in 1 Hour</a>
                        </p>
                        <p>第三, 预处理部分。这里的第三类(第二个坏类别)的划分依据是由于图片的尺寸限制, 使得边缘的物体被切割而成。因此取消了所有的裁剪类型的数据增强, 包括mixup, clip等。
                            同时为了弥补这方面的损失, 提高了Flip, Resize, ColorJitter等方法的比例. 另外Simple Copy Paste在该任务上效果较好。RandAugment暂时没有用, 不知道效果如何。
                        </p>
                        <p>同时, 以上调参大大增强了小目标的检测能力, 比Backbone为ResNet-50的原始SoloV2模型mAPs高了将近10倍, 蛮离谱的。</p>
                    </div>
                </div>
            </div>

            <div class="item" id="i2">
                <div class="main-title">
                    2022-09-02
                </div>
                <div class="main-content">
                    <div class="content-title">Selenium 爬虫框架</div>
                    <div class="content" id="content">
                        <p>起因来源于实习中的一个小任务, 平常是基本不做爬虫的</p>
                        <p>既然提到了Selenium这个框架, 那肯定是基本的url.request无法满足这里的需求</p>
                        <hr class="text-hr">
                        <p>在依靠ajax等框架加载的网页中, 由于其异步问题, 网页中的所有内容是不会一下子全部加载出来的需要靠脚本后端往服务器里要数据, 通过url.request打印的信息也是如此只能打印一部分静态网页和大量的JS脚本
                            而其实远远不止这些。具体情况如下图所示:
                        </p>
                        <div class="imgbox"><img src="../assets/2022/9-2/1.png"></div>
                        <div class="imgbox"><img src="../assets/2022/9-2/2.png"></div>
                        <p>一般而言, url.request需要配合正则匹配来进行对应元素目标位置的锁定。但是既然出不来那也就无从谈起。</p>
                        <p>
                            因此, 我这里选择的方法是。采用Selenium通过搜索整个html code里的元素path, 来达到对应图片的爬取。
                            此外由于该网页存在下拉加载, 因此需要同时进行自动的下拉操作。
                        </p>
                        <p>Selenium框架会生成一个对应的浏览器窗口模拟行为进行网页的浏览和抓取</p>
                        <pre>
driver = webdriver.Chrome(options=hide())
driver.maximize_window()
driver.get(url) # url为对应的域名
                        </pre>
                        <p>这里的options调整了两个params, 都算是Chrome官方推荐的</p>
                        <pre>
chrome_options = Options()
chrome_options.add_argument('--disable-gpu')
chrome_options.add_argument('--hide-scrollbars')
                        </pre>
                        <p>
                            之后需要实现下拉功能, 一段简单的js代码:
                        </p>
                        <pre>
# 大概要下拉多少次, 300为在网页上所呈现的图片小图的高度估值, 可小不可太大。
for i in range(1, 10000): 
    if (i - 1) % 4 == 0:
        dis = 300 * ((i - 1) // 4)
        js = "var q=document.documentElement.scrollTop={}".format(dis)
        driver.execute_script(js)</pre>
                        <p>
                            Selenium给我们提供了很多找元素的参照, 包括class / id / xpath。具体路径可在devtools里面找到, 对应元素右键即可。
                            重要的是找到你想要爬下来的这一批元素的共同点, 比如我这里是用Xpath路径, 只有一个地方不一样且是按规律变化的:
                        </p>
                        <pre>
xpath = '//*[@id="page_index"]/div/div[1]/div[2]/div[2]/div/div/div[{}]/img'.format(i)
elements = driver.find_elements_by_xpath(xpath)</pre>
                        <p>之后就是拿图片的地址并保存了。众所周知img标签下的地址为src。</p>
                        <pre>
for ele in elements:
    name = ele.text
    img_url = ele.get_attribute('src')
    print(i, name, img_url)
    if img_url:
        request.urlretrieve(img_url, f'./{title}/{i}.jpg')
        suc += 1
        print('-------------------------------')
    else:
        fal += 1
        print('----  this process errored, success = {}, failed = {}  ----'.format(suc, fal))
        break</pre>
                        <p>整体代码</p>
                        <pre>
from urllib import request
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import time

def hide():
    chrome_options = Options()
    chrome_options.add_argument('--disable-gpu')
    chrome_options.add_argument('--hide-scrollbars')
    return chrome_options

def process(url, title):
    driver = webdriver.Chrome(options=hide())
    driver.maximize_window()
    driver.get(url)

    suc, fal = 0, 0

    for i in range(1, 10000):
        if (i - 1) % 4 == 0:
            dis = 300 * ((i - 1) // 4)
            js = "var q=document.documentElement.scrollTop={}".format(dis)
            driver.execute_script(js)

        xpath = '//*[@id="page_index"]/div/div[1]/div[2]/div[2]/div/div/div[{}]/img'.format(i)
        elements = driver.find_elements_by_xpath(xpath)
        if not elements:
            break
        time.sleep(0.2)
        for ele in elements:
            name = ele.text
            img_url = ele.get_attribute('src')
            print(i, name, img_url)
            if img_url:
                request.urlretrieve(img_url, f'./{title}/{i}.jpg')
                suc += 1
                print('-------------------------------')
            else:
                fal += 1
                print('----  this process errored, success = {}, failed = {}  ----'.format(suc, fal))
                break

def main():
    url2title = ['https://111.com', '1'],
                ['https://222.com', '2'],
                ['https://333.com', '3'],
                ['https://444.com', '4']]
    process()

main()</pre>

                    <hr class="text-hr">
                    
                    <p>然后是一个同学委托的企查查的网页数据爬取, 从一个EXCEL表格读取一系列指定的企业名称并获得三项信息</p>
                    <p>
                        具体代码和注释见下, 值得注意的是这类需要登录的网站, 需要指定个人保存登录信息的文件夹, 并事先给予自己一定的前置时间。
                        另外整体操作不能太快, 例如爬取一家公司的信息后间隔一会儿再进行下一个公司信息的爬取进程, 否则容易被限制IP (企查查可以通过购买会员的方式解决, 但别的网站就不一定了)。
                    </p>

                    <pre>
from selenium import webdriver
from selenium.webdriver.common.by import By
import pandas as pd
import numpy as np
import re
import time


def opt():
    '''
        Chrome浏览器作为爬虫主体, 大概设置
    '''

    option = webdriver.ChromeOptions()
    option.add_experimental_option('excludeSwitches', ['enable-automation'])
    option.add_experimental_option('useAutomationExtension', False)
    option.add_argument(
        '--user-agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36"')  # user-agent请求头伪装
    option.add_argument(
        r"user-data-dir=C:\Users\Longking\AppData\Local\Google\Chrome\User\User Data")  # 登录信息保存默认文件夹
    return option


def get_page_html(firm_name, driver, interval=0.3):
    inputBox = driver.find_element(By.CSS_SELECTOR, '#searchKey')  # 获取搜索栏
    searchBtn = driver.find_element(By.CSS_SELECTOR, '.input-group-btn>.btn-primary')  # 获取搜索按钮

    time.sleep(interval)  # 等待-输入-等待-点击-跳转
    inputBox.clear()
    inputBox.send_keys(firm_name)
    time.sleep(interval)
    driver.execute_script('arguments[0].click()', searchBtn)

    try:
        # 万一没有这家公司就直接跳过
        css_txt = "body>div>div.app-search>div.container.m-t>div.adsearch-list>div>div.msearch.select-search-enable>div>table>tr>td:nth-child(3)>div>div.app-copy-box.copy-hover-item.copy-part>span.copy-title"  # 获取点击的超链接
        itemLink = driver.find_element(By.CSS_SELECTOR, css_txt)
        time.sleep(interval)
        itemLink.click()

        try:
            # 万一没有注销时间直接跳过
            all_handle = driver.window_handles
            driver.switch_to.window(all_handle[-1])  # 将句柄置于当前窗口

            css_txt = ".bar-click"  # 获取位置元素
            try:

                zhuxiao_time = driver.find_element(By.CSS_SELECTOR, css_txt)
                zhuxiao = zhuxiao_time.text
                zhuxiao = re.findall(r'[0-9]+-[0-9]+-[0-9]+', zhuxiao)[0]  # 剪掉多余信息
            except:
                zhuxiao = 'none'
            time.sleep(interval)

            css_txt = "#cominfo>div.cominfo-normal>table>tr:nth-child(5)>td:nth-child(4)"
            try:
                yingye_qixian = driver.find_element(By.CSS_SELECTOR, css_txt)
                yingye = yingye_qixian.text
            except:
                yingye = 'none'
            time.sleep(interval)

            css_txt = "#cominfo>div.cominfo-normal>table>tr:nth-child(6)>td:nth-child(6)>div>span.copy-value"
            try:
                hezhun_qixian = driver.find_element(By.CSS_SELECTOR, css_txt)
                hezhun = hezhun_qixian.text
            except:
                hezhun = 'none'
            time.sleep(interval)

            return [zhuxiao, yingye, hezhun], True
        except:
            return ['level2', 'level2', 'level2'], False
    except:
        return ['leve1', 'leve1', 'leve1'], False


def main(login_prepare=5, change=10):
    """ 以获取注销时间为案例, login_prepare为预留的手动登录的时间, change为切换公司的等待时间, 单位为秒 """

    data = pd.read_excel('output.xlsx')  # 表格第一行不是表头, 所以跳过从第二行开始读

    total = data.shape[0]  # 总行数
    zhuxiao_list = [''] * total  # 列表程度保持和总行数相同
    yingye_list = [''] * total
    hezhun_list = [''] * total

    if '注销时间' in data.columns:
        zhuxiao_list = list(data['注销时间'])
        yingye_list = list(data['营业期限'])
        hezhun_list = list(data['核准日期'])

        for i in range(total):
            if type(zhuxiao_list[i]) == float:
                idx = i
                print(idx)
                break
    else:
        idx = 0

    driver = webdriver.Chrome(options=opt())  # 浏览器选项加入
    driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {
        "source": """
        Object.defineProperty(navigator, 'webdriver', {
            get: () => undefined
        })
        """
    })  # 防止被检测
    driver.maximize_window()  # 窗口最大化, 小了的话可能拿不到元素
    driver.get('https://www.qichacha.com/user_login')  # 从登录开始
    time.sleep(login_prepare)  # 等待手动登录时间

    while idx < total:  # 获取每一个公司名称
        firm = data['企业名称'][idx]
        print(f'---- Now ==> {firm}')
        [zx, yy, hz], condition = get_page_html(firm, driver)  # 主函数
        print([zx, yy, hz])  # 没有填None, 有的话就填原来的。
        if condition:
            zhuxiao_list[idx] = zx
            yingye_list[idx] = yy
            hezhun_list[idx] = hz
        else:
            zhuxiao_list[idx] = 'none'
            yingye_list[idx] = 'none'
            hezhun_list[idx] = 'none'

        memory = idx + 1

        if memory % 10 == 0:  # 每10个公司保存一次, 可自己更改
            data_copy = data.copy()
            data_copy.loc[:, '注销时间'] = zhuxiao_list
            data_copy.loc[:, '营业期限'] = yingye_list
            data_copy.loc[:, '核准日期'] = hezhun_list
            data_copy.to_excel('output.xlsx', index=None)

        idx += 1
        time.sleep(change)

    data_copy = data.copy()
    data_copy.loc[:, '注销时间'] = zhuxiao_list
    data_copy.loc[:, '营业期限'] = yingye_list
    data_copy.loc[:, '核准日期'] = hezhun_list
    data_copy.to_excel('output.xlsx', index=None)


main()
                    </pre>

                    </div> 
                </div>
            </div>
            
            <!---->

            <div class="item" id="i3">
                <div class="main-title">
                    2022-09-04
                </div>
                <div class="main-content">
                    <div class="content-title">Github-Pages Tips</div>
                    <div class="content" id="content">
                        <p>
                            该条目长期更新, 为个人使用Github服务器挂靠网页时所遇到的问题记录, 尽量可以帮到希望使用Github-Pages作为自己的第一个个人主页的朋友。
                        </p>
                        <p>
                            Github-Pages整体用下来的感觉是: 很方便只需要写完后Push就行了; 不收你一分钱; 不会HTML的话也有基于Markdown的模板不过Theme有限。
                            缺点是国内网络在使用(push)的时候可能会受到客观的阻碍(建议使用全局模式), 访问是没问题的; 另外这是一个纯前端网页, 毕竟人家不会让你从服务器上拿数据, 你的表单也不知道提交到哪里。
                        </p>
                        <p>
                            关于Github怎么注册, 怎么申请Page的Repo, 怎么push你的project, 这些步骤很简单搜一下就有了。好像Gitee也支持Pages功能了我没试过。
                        </p>
                        <hr class="text-hr">
                        <p>
                            <span style="font-weight: bold; font-style: italic;">1. index.html</span>
                        </p>
                        <p>
                            众所周知, 每一个网站都是有个主页的。而Github-Pages的主页的网页名称必须为<span style="color: red;">index</span>,
                            且必须放在repo的最上层目录。如果你是用Markdown使用模板作为语言编写, 则还需要带有<span style="color: red;">config.yaml</span>(这个东西创建完主题会自带),
                            这个yaml文件里保存了你所使用的主题, 网页的名称, header显示的内容等。
                        </p>
                        <p>
                            另外提一嘴, 如果你从没有过代码项目的经历, 请记住所有的路径引用必须为相对路径, 毕竟你也不知道github给你的绝对路径是什么。网站代码开源可以去我的Github Repo里面直接查看。
                        </p>
                        <hr class="text-hr">
                        <p>
                            <span style="font-weight: bold; font-style: italic;">2. Error with Permissions-Policy header</span>
                        </p>
                        <p>
                            完整报错命令为<span style="color: blue; font-style:italic">Error with Permissions-Policy header: Origin trial controlled feature not enabled: 'interest-cohort'</span>.
                            可以在DevTools中查看。我这边发现此错误的原因是使用了JQuery官网下载下来的脚本库, 在Chrome浏览器上触发了谷歌的同类群组联合学习技术: Federated Learning of Cohorts(edge浏览器正常运行),
                            而Github也是反该项技术可能会抓取用户隐私的成员之一, 具体解释可查看<a href="https://blog.csdn.net/WHQ78164/article/details/120566824">这里</a>。解决方法是使用CDN分发, 我这边用的是微软的分发。
                        </p>
                    </div>
                </div>
            </div>

            <!---->

            <div class="item" id="i4">
                <div class="main-title">2022-11-26</div>
                <div class="main-content">
                    <div class="content-title">如何规避Pyinstaller存在的种种打包Bug</div>
                    <div class="content" id="content">
                        <p>
                            众所周知, 在Py上打包一些较为简易的程序, 大多数还是会用Pyinstaller。但是吧代码量小还好, 代码量大的话经常会出现这个没打包进去, 那个DDL缺失的情况。
                            最近各类大大小小的软件也做了不少, 总结了一下值得注意的东西。
                        </p>
                        <hr class="text-hr">
                        <p>
                            怎么使用就不介绍了, 我一般不会把其打包成一个总的, 运行速度太慢, 即加上参数 -D -w。
                            有人会问如果我的程序打包存在问题, 但我没法儿发现怎么办。这里我所知道的大概有三种解决方法:
                            <ol>
                                <li>Python traceback</li>
                                <p>
                                    比如你的代码里, 某一个类是主类然后主要也靠它调用东西, 那么你就可以用traceback去掌握报错信息。
                                    此方法也特别适合你懒得写那么多的专门的ValueError的提示框和判断, 也适合打包程序后的Debug处理。
                                </p>
                                <pre>
class MainClass:
    ...
    ...
    def start(self):
        ...
                                </pre>
                                <p>这个时候就很适合去加一个hook并回溯报错了。具体是这样的(PyQt5的程序)</p>
                                <pre>
import sys

class MainClass:
    ...
    def __init__(self):
        self.old_hook = sys.excepthook
        sys.excepthook = self._catch_error

    def _catch_error(self, ty, value, tb):
        traceback_format = traceback.format_exception(ty, value, tb)
        traceback_string = "".join(traceback_format)
        QtWidgets.QMessageBox.critical(self, "额外报错, ", "{}".format(traceback_string))
        self.old_hook(ty, value, tb)
                                </pre>
                                <p>这样的话不管是什么稀奇古怪的报错, 都可以起到提示的作用, 你在IDE里看到的是啥报错这里就给你弹的是什么。可以掌管任何在此class里引用出现的函数变量和类。</p>

                                <li>命令行执行</li>
                                <p>方法如其名, windows cmd + xxx.exe 即可, 报错信息直接在命令行中输出。</p>
                                <li>Pyinstaller 打包时, 更改Spec文件</li>
                                <p>众所周知, 打包时一般会生成三类文件: build dir(打包流程) / dist dir(最终的软件) / xxx.spec(打包配置文件)。</p>
                                <p>而spec文件中可以通过更改 console和debug参数, 输出更为详细的报错信息, 并更改最终软件的形式来达到Debug的效果。但此方法支持的报错不支持软件内部操作报错。</p>
                            </ol>
                        </p>
                        <hr class="text-hr">
                        <p>
                            拿到了报错信息, 就要进行对应的操作了, 要是Code本身的报错还好, 看得懂知道在哪儿改。
                            但是由于Pyinstaller自身Package打包的兼容性问题, 经常会出现其他的一些问题。这里举几个经常会出现的问题。
                        </p>
                        <p>
                            <ol>
                                <li>Module xxx not found</li>
                                <p>提示说有什么包没打包进来, 常见的有scipy, xgboost, py4j。</p>
                                <p>解决方法: <span style="color: red;">直接将对应环境site-packages下的对应第三方包文件夹整体复制进来即可。</span></p>
                                <li>DLL load failed while importing xxx</li>
                                <p>在导入某第三方包时找不到对应的DLL文件, 信息会直接在锁定在import xxx那一行。</p>
                                <p>解决方法大致有三种: 
                                    <span style="color: red;">该第三方包的版本打包兼容性有误, 卸载并重新安装别的版本即可。</span>
                                    <span style="color: orange;">网络方法, 程序目录下缺少python3.dll文件, 将对应环境site-packages下的python3.dll和python3x.dll复制进来即可。</span>
                                    <span style="color: blue">有时候由于代码复杂, 某些DLL会存在没有复制进来的情况。若其他方法均失败, 编写一个基于相同importing package的简易软件并打包。
                                        若后者正常运行, 检查两者目录下DLL文件的异同, 并将后者目录下的DLL全数复制进第一个, 筛选复制也可以。哪怕是原也得打包Qt不是↓</span>
                                </p>
                                <div class="imgbox"><img src="../assets/2022/11-26/genshin.png" alt=""></div>
                            </ol>
                        </p>
                    </div>
                </div>
            </div>

            <!---->

            <div class="item" id="i5">
                <div class="main-title">
                    2023-03-05
                </div>
                <div class="main-content">
                    <div class="content-title">SpringBoot 3+ 整合MyBatis和MyBatisPlus</div>
                    <div class="content" id="content">
                        <p>困扰了我一个月的问题。</p>
                        <p>MyBatis和MyBatisPlus 二者之间关联较小, 无非是继承和被继承的关系, 基本上存在冲突也会报错。</p>
                        <p>
                            结论: 如果SpringBoot版本较高, 请使用MyBatisPlus 3.5.3.1及以上的版本,
                            否则会提醒缺少<i>sqlSessionFactory</i> 和 <i>sqlSessionTemplate</i> =>
                            即<span>Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required</span>
                        </p>
                        <p>若无法下载, 需要添加镜像文件</p>
                        <pre>
&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;ossrh&lt;/id&gt;
        &lt;name&gt;OSS Snapshot repository&lt;/name&gt;
        &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;
        &lt;release&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
        &lt;/release&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
                        </pre>
                        
                    </div>
                </div>
            </div>

            <!---->

            <div class="item" id="i6">
                <div class="main-title">2023-03-24</div>
                <div class="main-content">
                    <div class="content-title">MMEditing 简单使用</div>
                    <div class="content" id="content">
                        <p>
                            没研究过也更没做过超分, 但是项目又得用超分, 有人会选择<a href="https://github.com/XPixelGroup/BasicSR">BasicSR</a>,
                            这边还是选择的<a href="https://github.com/open-mmlab/mmediting">MMEditing</a>, 商汤的框架用惯了, 懒得写的时候直接就用。
                        </p>
                        <p>
                            网上的介绍比较少, 官方1.x的文档更新的也很有限。稍微写一下, 我这边只做了图像超分所以也只能写图像超分。
                        </p>
                        <p>
                            请注意, 该帮助仅支持0.x版本, 且似乎不支持MMagic。
                        </p>
                        <hr class="text-hr">
                        <p>
                            图像超分顾名思义, 你希望将一张分辨率较低的图像送进网络去获得一张高分辨率的图片。
                            因此在做数据的时候, 需要高分辨率的原图和低分辨率的对应图片。MMEditing在超分这块仅支持<a href="https://data.vision.ee.ethz.ch/cvl/DIV2K/">DIV2K</a>数据集, 且为修改过的DIV2K数据集。
                            整个数据集分为三块: 本身和下采样2 3 4倍的对应图像, Set5和Set14的两个验证集。请注意,
                            <span style="color: red;">Set5 和 Set14数据集也是超分的Benchmark之一, 下载地址请见<a href="https://www.kaggle.com/datasets/jesucristo/super-resolution-benchmarks">这里</a>。不过最终发现不要这个也行。</span>
                        </p>
                        <p>整个数据集文件夹最终的呈现效果如下方所示。<span style="color: red;">请注意: 所有文件必须为png格式, 且不同文件夹下对应图片名称相同。</span></p>
                        <pre>
data
├─DIV2K
│  ├─DIV2K_train_HR         &lt;--- 原分辨率的图片, 训练集
│  ├─DIV2K_train_LR_bicubic
│  │  ├─X2          &lt;--- 2倍下采样
│  │  ├─X3          &lt;--- 3倍下采样
│  │  └─X4          &lt;--- 4倍下采样
│  ├─DIV2K_valid_HR         &lt;--- 原分辨率的图片, 验证集
│  └─DIV2K_valid_LR_bicubic
│      ├─X2          
│      ├─X3
│      └─X4
├─val_set14         &lt;--- 更改名字即可
│  ├─Set14_mod12
│  ├─original
│  ├─Set14_bicLRx2
│  ├─Set14_bicLRx3
│  └─Set14_bicLRx4
└─val_set5          &lt;--- 更改名字即可
    ├─Set5_mod12
    ├─original
    ├─Set5_bicLRx2
    ├─Set5_bicLRx3
    └─Set5_bicLRx4</pre>
                        <hr class="text-hr">
                        <p>
                            第一步当然是要做这个数据集。
                        </p>
                        <p>
                            下采样的方法其实从文件夹命名就可以看出来, 一个bicubic就能搞定。
                            代码参照<a href="https://blog.csdn.net/Crystal_remember/article/details/122899283">这里</a>并做了下修改
                        </p>
                        <pre>
import os
import argparse
import cv2
 
parser = argparse.ArgumentParser(description='Downsize images at 2x using bicubic interpolation')
parser.add_argument("-k", "--keepdims", help="keep original image dimensions in downsampled images", action="store_true")
parser.add_argument('--hr_img_dir', type=str, default=None,
                    help='path to high resolution image dir')
parser.add_argument('--lr_img_dir', type=str, default=None,
                    help='path to desired output dir for downsampled images')
args = parser.parse_args()
 
hr_image_dir = args.hr_img_dir
lr_image_dir = args.lr_img_dir
 
 
os.makedirs(lr_image_dir + "/X2", exist_ok=True)
os.makedirs(lr_image_dir + "/X3", exist_ok=True)
os.makedirs(lr_image_dir + "/X4", exist_ok=True)
 
supported_img_formats = (".bmp", ".dib", ".jpeg", ".jpg", ".jpe", ".jp2",
                         ".png", ".pbm", ".pgm", ".ppm", ".sr", ".ras", ".tif",
                         ".tiff")
 

for filename in os.listdir(hr_image_dir):
    if not filename.endswith(supported_img_formats):
        continue
 
    name, ext = os.path.splitext(filename)
 
    hr_img = cv2.imread(os.path.join(hr_image_dir, filename))
    hr_img_dims = (hr_img.shape[1], hr_img.shape[0])
 
    hr_img = cv2.GaussianBlur(hr_img, (0,0), 1, 1)
    lr_image_2x = cv2.resize(hr_img, (0,0), fx=0.5, fy=0.5, interpolation=cv2.INTER_CUBIC)
    if args.keepdims:
        lr_image_2x = cv2.resize(lr_image_2x, hr_img_dims, interpolation=cv2.INTER_CUBIC)
 
    cv2.imwrite(os.path.join(lr_image_dir + "/X2", filename.split('.')[0] + ext), lr_image_2x)
 
    lr_img_3x = cv2.resize(hr_img, (0, 0), fx=(1 / 3), fy=(1 / 3),
                           interpolation=cv2.INTER_CUBIC)
    if args.keepdims:
        lr_img_3x = cv2.resize(lr_img_3x, hr_img_dims,
                               interpolation=cv2.INTER_CUBIC)
    cv2.imwrite(os.path.join(lr_image_dir + "/X3", filename.split('.')[0] + ext), lr_img_3x)
 
    lr_img_4x = cv2.resize(hr_img, (0, 0), fx=0.25, fy=0.25,
                           interpolation=cv2.INTER_CUBIC)
    if args.keepdims:
        lr_img_4x = cv2.resize(lr_img_4x, hr_img_dims,
                               interpolation=cv2.INTER_CUBIC)
    cv2.imwrite(os.path.join(lr_image_dir + "/X4", filename.split('.')[0] + ext), lr_img_4x)</pre>
                        <hr class="text-hr">
                        <p>
                            第二步在MMEditing内预处理数据集
                        </p>
                        <p>
                            官方提供的数据集格式有 SRAnnotationDataset --> 以图片文件和独立的ann.txt文件组成;
                            SRFolderDataset --> 直接以图片文件组成;
                            SRLmdbDataset --> 以图片和lmdb文件组成。官方建议的是使用lmdb数据集, io处理速度快, 但是以文件夹为核心的数据集也不错, 起码制作起来简单。
                        </p>
                        <p>
                            为了扩充数据 (和获取ann.txt及lmdb文件), 首先得进一遍 tools/data/super-resolution/div2k/preprocess_div2k_dataset.py。
                            具体命令为 (假设你的数据文件夹名为data, 如同上方所示):
                        </p>
                        <pre>
python tools/data/super-resolution/div2k/preprocess_div2k_dataset.py --data-root ./data/DIV2K --make-lmdb</pre>
                        <p>
                            之后你的data文件夹多了几个lmdb和_sub文件夹, 如下方所示。_sub文件夹内即为经裁剪后的图片, lmdb就是所需的数据文件了。
                        </p>
                        <pre>
data
├── DIV2K
│   ├── DIV2K_train_HR
│   ├── DIV2K_train_HR_sub
│   ├── DIV2K_train_HR_sub.lmdb
│   │   ├── data.mdb
│   │   ├── lock.mdb
│   │   ├── meta_info.txt
│   ├── DIV2K_train_LR_bicubic
│   │   ├── X2
│   │   ├── X3
│   │   ├── X4
│   │   ├── X2_sub
│   │   ├── X3_sub
│   │   ├── X4_sub
│   ├── DIV2K_train_LR_bicubic_X2_sub.lmdb
│   ├── DIV2K_train_LR_bicubic_X3_sub.lmdb
│   ├── DIV2K_train_LR_bicubic_X4_sub.lmdb
│   ├── ...</pre>
                        <p>
                            这时候有人就会问为什么valid没有执行这一步骤, 因为默认确实不执行, 不过也好说。train_pipeline用lmdb, val_pipeline就用folder呗。毕竟val也不做裁剪。
                        </p>
                        <hr class="text-hr">
                        <p>
                            第三步修改配置文件
                        </p>
                        <p>
                            如果你之前接触过类似于paddlepaddle, mmcv这类多任务的开源框架的话, 改配置对你来说就肯定不算难事情了。
                            你如果不改网络结构的话, 也就Augmentation / lr_config / loss and optimizer 和日志以及保存部分需要改。
                        </p>
                        <p>
                            不过既然是超分, 那就难免有不同的地方。所以就列举几个比较特殊的需要更改的点,
                            大体例子参照官方提供的<a href="https://mmediting.readthedocs.io/zh_CN/latest/config.html#id8">EDSR模型配置文件</a>。不是很了解的也可以顺便看看对应参数的解释。
                            <span style="color: red;">请注意, 该配置文件仅训练2倍下采样的数据。可在scale处修改。</span>
                        </p>
                        <p>
                            如果使用的是 SRAnnotationDataset 数据集格式进行训练, 则需要修改以下位置:
                        </p>
                        <pre>
# data -> train -> dataset
lq_folder='data/DIV2K/DIV2K_train_LR_bicubic/X2_sub'
gt_folder='data/DIV2K/DIV2K_train_HR_sub'
ann_file='data/DIV2K/DIV2K_train_HR_sub.lmdb/meta_info.txt'         &lt;--- 经preprocess_div2k_dataset.py处理后生成的txt文件

# data -> val or test -> dataset
lq_folder='./data/val_set5/Set5_bicLRx2'
gt_folder='./data/val_set5/Set5_mod12'          &lt;--- 这里可以改为你想要当作验证和测试的数据文件夹, 因为默认是 SRFolderDataset 因此没有ann.txt</pre>
                        <p>
                            如果使用的是 SRLmdbDataset 数据集格式进行训练, 则需要修改以下位置:
                        </p>
                        <pre>
# train_dataset_type
train_dataset_type = 'SRLmdbDataset'

# data -> train -> dataset
lq_folder='data/DIV2K/DIV2K_train_LR_bicubic_X2_sub.lmdb'
gt_folder='data/DIV2K/DIV2K_train_HR_sub.lmdb
# 并注释掉原来的ann_file

# train_pipeline, 前两个dict
dict(
    type='LoadImageFromFile',
    io_backend='lmdb',
    key='lq',
    db_path='data/DIV2K/DIV2K_train_LR_bicubic_X2_sub.lmdb',
    flag='unchanged'),
dict(
    type='LoadImageFromFile',
    io_backend='lmdb',
    key='gt',
    db_path='data/DIV2K/DIV2K_train_HR_sub.lmdb',
    flag='unchanged')</pre>
                        <p>
                            其他修改:
                        </p>
                        <pre>
# evaluation
# 删除gpu_collect项</pre>
                    <hr class="text-hr">
                    <p>
                        第四步训练, 懂的都懂。
                    </p>
                    <hr class="text-hr">
                    <p>
                        第五步, 直接用api作推理。
                    </p>
                    <p>
                        如果你曾经使用过mmcv任何工具框架的api, 可能会像下面这样做:
                    </p>
                    <pre>
from mmedit.apis import init_model, restoration_inference

def infer_restoration(img, cfg, ckpt):
    model = init_model(config=cfg, checkpoint=ckpt, device="cuda:0")
    infer = restoration_inference(model=model, img=item))
    return infer

if __name__ == '__main__':
    res = infer_restoration(img="xxx.jpg",
                            cfg="xxx.py",
                            ckpt="xxx.pth")</pre>

                    <p>
                        然后你会发现, res矩阵里面全都是在0-1之间的数, 你可能会想到是不是做了归一化。
                        之后一通 *255 再 reshape 再 tensor.numpy(), 发现出来的结果怎么是原低分辨率的图复制了几次而已。
                        没辙了。
                    </p>
                    <p>
                        其实有一个叫做tensor2img的函数是需要一起配套使用的, 阅读源码发现是需要再另外做一系列后处理的,
                        即如下面所示即可:
                    </p>
                    <pre>
from mmedit.apis import init_model, restoration_inference
from mmedit.core import tensor2img

def infer_restoration(img, cfg, ckpt):
    model = init_model(config=cfg, checkpoint=ckpt, device="cuda:0")
    infer = tensor2img(restoration_inference(model=model, img=item)))
    return infer

if __name__ == '__main__':
    res = infer_restoration(img="xxx.jpg",
                            cfg="xxx.py",
                            ckpt="xxx.pth")</pre>
                    </div>
                </div>
            </div>

            <!---->

            <div class="item" id="i7">
                <div class="main-title">
                    2024-08-18
                </div>
                <div class="main-content">
                    <div class="content-title">录制电脑音视频</div>
                    <div class="content" id="content">
                        <p>厌烦了主持人没开会议录屏权限的情况</p>
                        <p>原理很简单, 一个线程录音频一个线程录视频, 最后融合。</p>
                        <p>录视频很轻松, opencv write video即可。但音频较为复杂。</p>
                        <p>
                            1. 首先, 你或许知道用pyaudio或者sounddevice捕捉音频设备。但这时你会发现, 若你带了蓝牙耳机, pyaudio所列出的设备列表中,
                            蓝牙设备是没有输入通道的, 这就意味着你根本无法获取电脑音频, 总不能每次录制会议要开扬声器吧。
                        </p>
                        <p>
                            好在你或许想到微软是有音频类的API, 但你又发现pyaudio似乎并不支持。
                        </p>
                        <p>
                            那我恭喜你发现了问题的所在, 你只需要安装一个pyaudio的plus版本, <i href="https://github.com/s0d3s/PyAudioWPatch">PyAudioWPatch</i>。
                            示例当中有解决这类问题的方法。于是这个时候你只需要列出设备列表, 找到WASABI API支持的蓝牙设备序号即可。示例代码见下:
                        </p>
                        <pre>
import pyaudiowpatch as pyaudio

p = pyaudio.PyAudio()
devices = []
for i in range(p.get_device_count()):
    device = p.get_device_info_by_index(i)
    if device["isLoopbackDevice"]:
        devices.append(device)
                        </pre>
                        <p>2. 其次, 当你按照网上示例运行录制音频代码时, 可能会发现为什么我录制出来的音频这么卡。这时候只需要调整buffer>=2048即可, 个人经验。</p>
                        <p>
                            3. 最后, 有的朋友肯定会像我一样, 做个录屏软件出来, 那么在融合的时候我希望知道融合过程的信息(例如moviepy)。
                            但moviepy都是在控制台输出进度条, 又长又麻烦, 怎么办呢?
                        </p>
                        <p>
                            write_videofile函数有一个logger参数, 这个参数比较复杂, 需要传入一个自定义的proglog对象。通过重写相关类, 在线程中用变量获取进度条信息, 步骤信息等。
                            示例代码见下:
                        </p>
                        <pre>
""" BaseRecordThread继承QThread """

class FusionRecordThread(BaseRecordThread):
    complete_signal = pyqtSignal(int)
    params_signal = pyqtSignal(str)
    bars_signal = pyqtSignal(float)

    def __init__(self, filenames: list):
        super().__init__()
        self.filenames = filenames

    def run(self) -> None:

        class MyBarLogger(ProgressBarLogger):
            def __init__(self, p_s, b_s):
                super().__init__()
                self.ps = p_s
                self.bs = b_s

            def callback(self, **changes):
                for (parameter, value) in changes.items():
                    if parameter == "message":
                        if value.find("Writing audio") >= 0:
                            self.ps.emit("重写音频中...")
                        else:
                            self.ps.emit("混合中...")

            def bars_callback(self, bar, attr, value, old_value=None):
                percentage = (value / self.bars[bar]['total']) * 100
                self.bs.emit(round(percentage, 2))

        self.running = True
        logger = MyBarLogger(p_s=self.params_signal, b_s=self.bars_signal)
        video_file = self.filenames[1]
        video_clip = VideoFileClip(video_file)

        audio_file = self.filenames[0]
        audio_clip = AudioFileClip(audio_file)

        video_with_audio = video_clip.set_audio(audio_clip)
        video_with_audio.write_videofile(self.filenames[-1], codec='libx264', audio_codec='aac', logger=logger)

        video_clip.close()
        audio_clip.close()

        self.complete_signal.emit(1)
                        </pre>
                        <p>4. 未解决的问题。当音频和视频线程同时运作时, 视频会存在丢帧现象, 即便分离提取和写入为两个线程也无法解决, 最高只能达到15帧。希望各位多多交流</p>
                    </div>
                </div>
            </div>
            
        </div>
        
    </div>
    
    <div class="bottom">
        <hr class="shadow">
        <br>
        Right, wrong... Nobody's got a clue what the difference is in this town. So I'm gonna have more fun... and live crazier than any of 'em.
        <br>
        Goro Majima
    </div>

    <script>
        $(".next-link > a").click(function(){
            var idx = $(".next-link > a").index(this)
            $("#i"+ idx).siblings(".item").css({"display":"none"})
            $("#i"+ idx).css({"display":"block"})
        })
    </script>

</body>
</html>